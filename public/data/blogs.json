[
    {
        "id": 1,
        "title": "Maps en Javascript",
        "description": "MÃ©todos y usos",
        "field": "<p style=\"text-align: justify;\">El objeto<code> Map <\/code>puede no ser del todo utilizado al momento de crear nuestras aplicaciones, pero dentro de sus m&eacute;todos tiene muchas utilidades que nos pueden ayudar mucho si sabemos c&oacute;mo implementarlas.<\/p>\r\n <p style=\"text-align: justify;\">&nbsp;<\/p>\r\n <p style=\"text-align: justify;\">En resumen, Map es un objeto que guarda el par key-value y recuerda el orden en el que fueron agregados. Este par puede ser de cualquier tipo, tanto objetos como primitivos.<\/p>\r\n <p style=\"text-align: justify;\">&nbsp;<\/p>\r\n <p style=\"text-align: justify;\">&iexcl;Veamos c&oacute;mo se utiliza!<\/p>\r\n <p style=\"text-align: justify;\">&nbsp;<\/p>\r\n <p style=\"text-align: justify;\">La manera de comenzar a utilizar map es creando un objeto a partir de su prototipo.<\/p>\r\n <p>&nbsp;<\/p>\r\n <pre class=\"language-javascript\"><code>const myMap = new Map();<\/code><\/pre>\r\n <p style=\"text-align: justify;\">Ahota bien, Map tiene muchas propiedades, siendo <code>set<\/code>&nbsp;y <code>get<\/code> las que m&aacute;s ampliamente utilizadas. Sin embargo, si hacemos el ejercicio de colocar en nuestro editor de c&oacute;digo un punto luego de <code>myMap<\/code>, veremos que podremos acceder a un listado largo de m&eacute;todos.&nbsp;<\/p>\r\n <p style=\"text-align: justify;\">&nbsp;<\/p>\r\n <p style=\"text-align: justify;\">En este articulo veremos las principales.<\/p>\r\n <p>&nbsp;<\/p>\r\n <p>&nbsp;<\/p>\r\n <p><strong>Insertar valores en un Map<\/strong><\/p>\r\n <p>&nbsp;<\/p>\r\n <p style=\"text-align: justify;\">Como seguramente ya adivinaste, el m&eacute;todo que nos permite agregar un valor a nuestro objeto se llama <code>set()<\/code>:<\/p>\r\n <p>&nbsp;<\/p>\r\n <pre class=\"language-javascript\"><code>myMap.set(1, 'John' )\r\n myMap.set(2, 'Jane' )\r\n myMap.set(3, 'Jack' )\r\n myMap.set(4, 'Jill' )\r\n myMap.set(5, 'Joe' )<\/code><\/pre>\r\n <p>&nbsp;<\/p>\r\n <p style=\"text-align: justify;\">Si intentamos mandar este c&oacute;digo a la consola, nos encontraremos con lo siguiente:<\/p>\r\n <p>&nbsp;<\/p>\r\n <pre class=\"language-javascript\"><code>Map { 1 =&gt; 'John', 2 =&gt; 'Jane', 3 =&gt; 'Jack', 4 =&gt; 'Jill', 5 =&gt; 'Joe' }<\/code><\/pre>\r\n <p>&nbsp;<\/p>\r\n <p style=\"text-align: justify;\">Lo que podemos advertir es que Map nos est&aacute; contando cu&aacute;ntas propiedades estamos almacenando, como tambi&eacute;n, al estar utilizando =&gt;, podemos diferenciar los pares key-values.<\/p>\r\n <p>&nbsp;<\/p>\r\n <p>&nbsp;<\/p>\r\n <p><strong>Llamar los valores de un Map<\/strong><\/p>\r\n <p>&nbsp;<\/p>\r\n <p style=\"text-align: justify;\">El siguiente m&eacute;todo que podemos ver es <code>get()<\/code>, el cual nos permite obtener los valores almacenados dentro del Map.&nbsp;<\/p>\r\n <p style=\"text-align: justify;\">&nbsp;<\/p>\r\n <p style=\"text-align: justify;\">Primero veamos c&oacute;mo obtener todos los valores, para luego pasar a c&oacute;mo podemos hacer para llamara un valor en espec&iacute;fico.<\/p>\r\n <p style=\"text-align: justify;\">&nbsp;<\/p>\r\n <p style=\"text-align: justify;\">La manera que se utiliza para poder iterar sobre cada unos de los pares almacenados es con el <strong>for ... of<\/strong>.<\/p>\r\n <p>&nbsp;<\/p>\r\n <pre class=\"language-javascript\"><code>for(let pair of myMap){\r\n console.log(pair)\r\n }<\/code><\/pre>\r\n <p>&nbsp;<\/p>\r\n <p>obteniendo un array de cada par agregado:<\/p>\r\n <p>&nbsp;<\/p>\r\n <pre class=\"language-javascript\"><code>[ 1, 'John' ]\r\n [ 2, 'Jane' ]\r\n [ 3, 'Jack' ]\r\n [ 4, 'Jill' ]\r\n [ 5, 'Joe' ]<\/code><\/pre>\r\n <p>&nbsp;<\/p>\r\n <p style=\"text-align: justify;\">Podemos separar el par utilizando dor m&eacute;todos que nos permiten esta tarea.<\/p>\r\n <p style=\"text-align: justify;\">&nbsp;<\/p>\r\n <p style=\"text-align: justify;\">En primer lugar<code> keys()<\/code> la cual nos retorna del Map solo las keys que hayamos agregado.<\/p>\r\n <p>&nbsp;<\/p>\r\n <pre class=\"language-javascript\"><code>for(let keys of myMap.keys()){\r\n console.log(keys)\r\n }<\/code><\/pre>\r\n <p>&nbsp;<\/p>\r\n <p style=\"text-align: justify;\">Por otro lado, si lo que buscamos es unicamente los valores, tendremos que utilizar el m&eacute;todo <code>values()<\/code><\/p>\r\n <p>&nbsp;<\/p>\r\n <pre class=\"language-javascript\"><code>for(let values of myMap.values()){\r\n console.log(values)\r\n }<\/code><\/pre>\r\n <p>&nbsp;<\/p>\r\n <p style=\"text-align: justify;\">Si lo que queremos es obtener tanto la key como el valor, Map nos proporciona un m&eacute;todo llamado <code>entries()<\/code>, el cual permite obtener cada una de las entradas que hayamos ido insertando con cada <code>set()<\/code><\/p>\r\n <p>&nbsp;<\/p>\r\n <pre class=\"language-javascript\"><code>for(let key of myMap2.entries()){\r\n   console.log(key);\r\n }<\/code><\/pre>\r\n <p>&nbsp;<\/p>\r\n <p>Ahora bien, tambi&eacute;n podemos desestructurar <code>myMap<\/code> para obtener por separado tanto la key como el value sin la necesidad de llamar a sus m&eacute;todos.<\/p>\r\n <p>&nbsp;<\/p>\r\n <pre class=\"language-javascript\"><code>for(let [key, value] of myMap){\r\n console.log(key, value)\r\n }<\/code><\/pre>\r\n <p>&nbsp;<\/p>\r\n <p style=\"text-align: justify;\">Lo que debemos de tener en cuenta si dedicimos utilizar esta &uacute;ltima manera de iterar nuestro <code>Map<\/code> es que en la desestructuraci&oacute;n, el primer valor que obtenemos es el key y luego el value. Ahora puede parecer no tener sentido remarcar este detalle, pero luego, cuando pasemos al m&eacute;todo <code>forEach()<\/code> se dar&aacute;n cuenta del por qu&eacute; lo mencion&eacute;.<\/p>\r\n <p>&nbsp;<\/p>\r\n <p>&nbsp;<\/p>\r\n <p><strong>Entendiendo forEach<\/strong><\/p>\r\n <p>&nbsp;<\/p>\r\n <p style=\"text-align: justify;\">Ahora veamos la parte confusa que podemos llegara a encontrar al utilizar Map.<\/p>\r\n <p style=\"text-align: justify;\">&nbsp;<\/p>\r\n <p style=\"text-align: justify;\">El m&eacute;todo <code>forEach()<\/code>, al igual que el m&eacute;todo dentro de los arrays, hace una iteraci&oacute;n en cada uno de los elementos, permiti&eacute;ndonos que podamos obtener sus keys y values, como hacer todo tipo de l&oacute;gica que nuestras aplicaciones est&eacute;n necesitando.<\/p>\r\n <p>&nbsp;<\/p>\r\n <pre class=\"language-javascript\"><code>myMap.forEach((value, key) =&gt; {\r\n   console.log(value, key)\r\n })<\/code><\/pre>\r\n <p>&nbsp;<\/p>\r\n <p style=\"text-align: justify;\">Ahora bien, si notaron algo diferente utilizando <code>forEach()<\/code>, respecto a cuando utiliz&aacute;bamos <strong>for...of<\/strong> est&aacute;n en lo cierto. Cuando vimos la iteraci&oacute;n por medio de <strong>for...of<\/strong>, al momento de desestructurar el elemento para poder obtener tanto la key como el valor, les dije que el primer \"valor\" que obtenermos es la key, y luego el value. En el caso del m&eacute;todo forEach sucede lo opuesto. Si intentamos primero obtener la key y luego el value, nos regresar&aacute; los valores dado vueltas, ya que primero nos retorna el valor.<\/p>\r\n <p style=\"text-align: justify;\">&nbsp;<\/p>\r\n <p style=\"text-align: justify;\">Esto se debe a que forEach est&aacute; pensado para trabajar con los valores. En un <code>Map<\/code>, las key son considerados los &iacute;ndices, por lo que no te ser&aacute;n proporcionados en este m&eacute;todo a diferencia del for...of.<\/p>\r\n <p>&nbsp;<\/p>\r\n <p>&nbsp;<\/p>\r\n <p><strong>Borrar valores en un Map<\/strong><\/p>\r\n <p>&nbsp;<\/p>\r\n <p style=\"text-align: justify;\">Map nos permite poder eliminar cualquier entrada que hayamos realizando, tan solo colocando su key. En el caso de <code>Map<\/code>, borrar un par de key-value no traa mayores problemas, a diferencia de un Object, donde podemos perder optimizaci&oacute;n y nos recomendado seg&uacute;n especificaciones de v8.<\/p>\r\n <p style=\"text-align: justify;\">&nbsp;<\/p>\r\n <p style=\"text-align: justify;\">Para poder realizar esta acci&oacute;n, haremos uso del m&eacute;todo <code>delete()<\/code><\/p>\r\n <p>&nbsp;<\/p>\r\n <pre class=\"language-javascript\"><code>myMap.delete(2)<\/code><\/pre>\r\n <p>&nbsp;<\/p>\r\n <p style=\"text-align: justify;\">&iquest;Y solo as&iacute;? Exacto, con solo ese m&eacute;todo ya no tendremos el par key-value, cuyo key sea igual a 2.<\/p>\r\n <p style=\"text-align: justify;\">&nbsp;<\/p>\r\n <p style=\"text-align: justify;\">Pero todav&iacute;a queda algo m&aacute;s por decir al utilizar <code>delete()<\/code>. El mismo m&eacute;todo nos retorna un valor al momento de borrar un elemento. Suponiendo que la key a la que intentamos acceder para eliminar exista, el valor que nos devolveran ser&aacute; true, confirmando de esta manera que la entrada se elimin&oacute;, pero en caso de que no exista la key obtendremos un false.<\/p>\r\n <p>&nbsp;<\/p>\r\n <p>&nbsp;<\/p>\r\n <p><strong>Verificar keys<\/strong><\/p>\r\n <p>&nbsp;<\/p>\r\n <p style=\"text-align: justify;\">Otro m&eacute;todo similar al anterior que nos retorna un booleano, es el m&eacute;todo <code>has()<\/code>, el cual nos permite poder consultar si existe una entrada con ese valor de key.<\/p>\r\n <p>&nbsp;<\/p>\r\n <pre class=\"language-javascript\"><code>const existElement = myMap.has('John')<\/code><\/pre>\r\n <p>&nbsp;<\/p>\r\n <p style=\"text-align: justify;\">El m&eacute;todo es verdaderamente importante cuando nos encontramos realizando consulta o correcciones, ya que nos ahorra tener que implementar un loop que recorra al Map para verificar si existe o no.<\/p>\r\n <p>&nbsp;<\/p>\r\n <p>&nbsp;<\/p>\r\n <p><strong>Otros m&eacute;todos<\/strong><\/p>\r\n <p>&nbsp;<\/p>\r\n <p><code>Map.clear() <\/code>- remueve todos los elementos del map.<\/p>\r\n <p><code>Map.size()<\/code> - nos retorna el n&uacute;mero de entradas que hayamos realizado.<\/p>\r\n <p>&nbsp;<\/p>\r\n <p>&nbsp;<\/p>\r\n <p><strong>Ejemplo pr&aacute;ctico<\/strong><\/p>\r\n <p>&nbsp;<\/p>\r\n <p style=\"text-align: justify;\">Imaginemos que trabajamos en una escuela que nos encarga entregarlo un listado de alumnos con edades y tel&eacute;fonos, pero al ver la informaci&oacute;n nos encontramos con un problema. Por un lado, tenemos un listado de nombres y n&uacute;meros telef&oacute;nicos de cada alumno; por el otro lado, tenemos un listado que se realiz&oacute; sin tener en cuenta el primero y en el que constan los nombres y edades.<\/p>\r\n <p>&nbsp;<\/p>\r\n <pre class=\"language-javascript\"><code>const peopleAge = [{name: 'John', age: 20 }, {name: 'Sara', age: 21}, {name: 'Bob', age: 22}, {name: 'Mary', age: 23}, {name: 'Peter', age: 24}]\r\n \r\n const peoplePhone = [{name: 'John', phone: 1245645 }, {name: 'Sara', phone: 7878454212}, {name: 'Bob', phone: 123545697}, {name: 'Mary', phone: 1956324974}, {name: 'Peter', phone: 1234598732}]<\/code><\/pre>\r\n <p>&nbsp;<\/p>\r\n <p style=\"text-align: justify;\">Nuestra tarea consiste en unificar el listado, y en lugar de hacerlo uno por uno nos acordamos de una vez haber le&iacute;do una entrada interesante en la que nos ense&ntilde;aban a utilizar Map. Entonces deicimos ponerlo en pr&aacute;ctica y generamos el siguiente c&oacute;digo:<\/p>\r\n <p>&nbsp;<\/p>\r\n <pre class=\"language-javascript\"><code>let join = []\r\n \r\n peopleAge.forEach(ageList =&gt; {\r\n   const myMap = new Map()\r\n   myMap.set(ageList['name'], ageList)\r\n \r\n   peoplePhone.forEach(phoneList =&gt; {\r\n   const people = myMap.get(phoneList['name'])\r\n   if(people === undefined) return\r\n   join.push({...phoneList, ...people})\r\n   })\r\n });\r\n \r\n console.log(join);<\/code><\/pre>\r\n <p>&nbsp;<\/p>\r\n <p style=\"text-align: justify;\">Lo que hicimos fue iterar el primer listado de alumnos, guardando en un Map cada uno de los valores, utilizando como llave el nombre, el cual sabemos que est&aacute;n en ambos listados. Luego, en el mismo loop, hacemos una segunda iteraci&oacute;n, pero esta vez sobre el segundo listado, buscando, gracias al m&eacute;todo <code>get()<\/code> si en nuestro Map se encuentran los mismos alumnos. De ser positivo, entonces guardamos la entrada que nos retorna, junto al elementos sobre el que estamos iterando dentro de un nuevo array que los agrupe.<\/p>\r\n <p>&nbsp;<\/p>\r\n <p>As&iacute; pudismos unificar los listados.<\/p>\r\n <p>&nbsp;<\/p>\r\n <p>&nbsp;<\/p>\r\n <p><strong>Conclusi&oacute;n<\/strong><\/p>\r\n <p>&nbsp;<\/p>\r\n <p style=\"text-align: justify;\">Map es una excelente herramienta si nos encontramos en una aplicaci&oacute;n cuya principal funci&oacute;n sea el agregado o eliminaci&oacute;n de entradas.&nbsp;<\/p>\r\n <p>&nbsp;<\/p>",
        "img": "https://i.imgur.com/FJu6OQb.png",
        "created_at": "2023-07-22 20:33:56",
        "user" : "Alejandro Gomez Nieto",
        "category": "JavaScript"
    },
    {
        "id": 2,
        "title": "Memoria dinÃ¡mica en C++",
        "description": "Uso de punteros",
        "field": "<p id=\"3684\" class=\"pw-post-body-paragraph wz xa sd lw b xb xc xd xe xf xg xh xi lg xj xk xl ll xm xn xo lq xp xq xr xs fp bj xt\" style=\"text-align: justify;\" data-selectable-paragraph=\"\"><span class=\"l xu xv xw bn xx xy xz ya yb dj\">M<\/span>uchas veces no sabemos de antemano cu&aacute;nta memoria ser&aacute; necesaria para almacenar los datos que una variable definida pueda llegar a requerir; sin embargo, el tama&ntilde;o puede ser determinado durante la misma ejecuci&oacute;n del programa.<\/p>\r\n<p id=\"f87f\" class=\"pw-post-body-paragraph wz xa sd lw b xb xc xd xe xf xg xh xi lg xj xk xl ll xm xn xo lq xp xq xr xs fp bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">Cuando hablamos de memoria din&aacute;mica hacemos referencia a la reserva de espacio dentro de la Memoria Heap. &iquest;Pero qu&eacute; es la Memoria Heap?<\/p>\r\n<p id=\"9536\" class=\"pw-post-body-paragraph wz xa sd lw b xb xc xd xe xf xg xh xi lg xj xk xl ll xm xn xo lq xp xq xr xs fp bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">Cuando ejecutamos un programa el Sistema Operativo le asigna al proceso lo que se conoce como memoria virtual, de esta manera es posible su ejecuci&oacute;n. Esta memoria virtual se divide en segmentos:<\/p>\r\n<p id=\"1ed9\" class=\"pw-post-body-paragraph wz xa sd lw b xb xc xd xe xf xg xh xi lg xj xk xl ll xm xn xo lq xp xq xr xs fp bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\"><strong class=\"lw kx\">-Segmento Stack:&nbsp;<\/strong>Se tratan de viariables locales no inicializadas, funciones, llamadas, retornos, etc, etc, etc.<\/p>\r\n<p id=\"c515\" class=\"pw-post-body-paragraph wz xa sd lw b xb xc xd xe xf xg xh xi lg xj xk xl ll xm xn xo lq xp xq xr xs fp bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\"><strong class=\"lw kx\">-Segmento Heap:<\/strong> Se trata de una memoria adicional que podemos requerir durante la misma ejecuci&oacute;n del programa. Se gestiona con las instrucciones malloc, calloc, realloc y free.<\/p>\r\n<p id=\"8578\" class=\"pw-post-body-paragraph wz xa sd lw b xb xc xd xe xf xg xh xi lg xj xk xl ll xm xn xo lq xp xq xr xs fp bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\"><strong class=\"lw kx\">-Segmento Data: <\/strong>Contiene la inicializaci&oacute;n de las variables est&aacute;ticas, globales y est&aacute;ticas globales.<\/p>\r\n<p id=\"a951\" class=\"pw-post-body-paragraph wz xa sd lw b xb xc xd xe xf xg xh xi lg xj xk xl ll xm xn xo lq xp xq xr xs fp bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\"><strong class=\"lw kx\">-Segmento Text: <\/strong>Contiene las instrucciones ejecutables y es solo de lectura.<\/p>\r\n<p class=\"pw-post-body-paragraph wz xa sd lw b xb xc xd xe xf xg xh xi lg xj xk xl ll xm xn xo lq xp xq xr xs fp bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">&nbsp;<\/p>\r\n<h1 id=\"888b\" class=\"yc yd sd be ye yf yg yh lb yi yj yk lf yl ym yn yo yp yq yr ys yt yu yv yw yx bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\"><strong class=\"al\">Diferencia entre Heap y Stack<\/strong><\/h1>\r\n<p id=\"63b1\" class=\"pw-post-body-paragraph wz xa sd lw b xb yy xd xe xf yz xh xi lg za xk xl ll zb xn xo lq zc xq xr xs fp bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">La Memoria Stack es de estructura lineal, mientras que La Memoria Heap es jer&aacute;rquica.<\/p>\r\n<p id=\"5c0e\" class=\"pw-post-body-paragraph wz xa sd lw b xb xc xd xe xf xg xh xi lg xj xk xl ll xm xn xo lq xp xq xr xs fp bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">La Memoria Stack es m&aacute;s veloz que La Memoria Heap.<\/p>\r\n<p id=\"0a3b\" class=\"pw-post-body-paragraph wz xa sd lw b xb xc xd xe xf xg xh xi lg xj xk xl ll xm xn xo lq xp xq xr xs fp bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">El La Memoria Stack es gestionada por el sistema operativo para que nunca se fragmente; La Memoria Heap se puede fragmentar y no es tan eficiente.<\/p>\r\n<p id=\"5f90\" class=\"pw-post-body-paragraph wz xa sd lw b xb xc xd xe xf xg xh xi lg xj xk xl ll xm xn xo lq xp xq xr xs fp bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">En el La Memoria Stack solo podremos colocar variable locales, mientras que en el La Memoria Heap pueden ingresar las variables globales.<\/p>\r\n<p id=\"c976\" class=\"pw-post-body-paragraph wz xa sd lw b xb xc xd xe xf xg xh xi lg xj xk xl ll xm xn xo lq xp xq xr xs fp bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">El La Memoria Stack se asigna de manera autom&aacute;tica; el La Memoria Heap lo hace el programador.<\/p>\r\n<p id=\"1d36\" class=\"pw-post-body-paragraph wz xa sd lw b xb xc xd xe xf xg xh xi lg xj xk xl ll xm xn xo lq xp xq xr xs fp bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">El La Memoria Stack se lo implementa para matrices simples, memoria din&aacute;mica y basada en listas vinculadas. La Memoria Heap se usa para matrices y &aacute;rboles.<\/p>\r\n<p id=\"17f2\" class=\"pw-post-body-paragraph wz xa sd lw b xb xc xd xe xf xg xh xi lg xj xk xl ll xm xn xo lq xp xq xr xs fp bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">El tama&ntilde;o del La Memoria Stack es fija, mientras que La Memoria Heap se puede redimensionar.<\/p>\r\n<p class=\"pw-post-body-paragraph wz xa sd lw b xb xc xd xe xf xg xh xi lg xj xk xl ll xm xn xo lq xp xq xr xs fp bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">&nbsp;<\/p>\r\n<h1 id=\"4e63\" class=\"yc yd sd be ye yf yg yh lb yi yj yk lf yl ym yn yo yp yq yr ys yt yu yv yw yx bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\"><strong class=\"al\">New<\/strong><\/h1>\r\n<p id=\"6dfb\" class=\"pw-post-body-paragraph wz xa sd lw b xb yy xd xe xf yz xh xi lg za xk xl ll zb xn xo lq zc xq xr xs fp bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">Para poder asignar memoria durante la ejecuci&oacute;n de nuestro programa debemos utilizar un tipo de operador especial en C++ que nos devuelve la direcci&oacute;n del espacio asignado. Este operador es New.<\/p>\r\n<p id=\"a092\" class=\"pw-post-body-paragraph wz xa sd lw b xb xc xd xe xf xg xh xi lg xj xk xl ll xm xn xo lq xp xq xr xs fp bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">Para su uso debemos saber qu&eacute; tipo de dato vamos a almacenar, de esa manera podemos hacer uso de la siguiente sintaxis gen&eacute;rica:<\/p>\r\n<pre class=\"language-cpp\"><code>new data-type;<\/code><\/pre>\r\n<p style=\"text-align: justify;\">Data-type puede ser cualquier tipo de dato, incluido los vectores o matrices de alg&uacute;n tipo de dato espec&iacute;fico, como tambi&eacute;n clases o estructuras. Pero imaginemos que queremos hacer reserva en la Memoria Heap de un tipo de dato Int:<\/p>\r\n<pre class=\"language-cpp\"><code>int* numero = NULL;\r\n numero = new int;<\/code><\/pre>\r\n<p id=\"a9dc\" class=\"pw-post-body-paragraph wz xa sd lw b xb xc xd xe xf xg xh xi lg xj xk xl ll xm xn xo lq xp xq xr xs fp bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">Como dijimos m&aacute;s adelante, lo que nos retorna new es la direcci&oacute;n de memoria en la que se reserva el espacio donde vamos a almacenar los datos, por lo que es menester declarar una variable de tipo puntero (Recordemos que las variables punteros son las que utilizamos para almacenar direcciones de memoria).<\/p>\r\n<p id=\"6204\" class=\"pw-post-body-paragraph wz xa sd lw b xb xc xd xe xf xg xh xi lg xj xk xl ll xm xn xo lq xp xq xr xs fp bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">Entre los problemas que nos podemos encontrar al trabajar con Memoria Din&aacute;mica es que esta se haya agotado, por lo que es de buena pr&aacute;ctica verificar si el operador new efectivamente nos est&aacute; retornando un puntero NULL:<\/p>\r\n<pre class=\"language-cpp\"><code>int* numero  NULL;\r\n if(!(numero = int))\r\n {\r\n     std::cout &lt;&lt; \"Error: Sin Memoria\" &lt;&lt; std::endl;\r\n     exit(1)\r\n }<\/code><\/pre>\r\n<p style=\"text-align: justify;\">&nbsp;<\/p>\r\n<h1 id=\"7c76\" class=\"yc yd sd be ye yf yg yh lb yi yj yk lf yl ym yn yo yp yq yr ys yt yu yv yw yx bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\"><strong class=\"al\">Delete<\/strong><\/h1>\r\n<p id=\"1ca1\" class=\"pw-post-body-paragraph wz xa sd lw b xb yy xd xe xf yz xh xi lg za xk xl ll zb xn xo lq zc xq xr xs fp bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">Cuando nuestro programa ya no necesita hacer uso de la variable asignada din&aacute;micamente, podemos liberar la Memoria que est&aacute; ocupando utilizando el operador delete.<\/p>\r\n<pre class=\"language-cpp\"><code>int* numero  NULL;\r\n if(!(numero = int))\r\n {\r\n     std::cout &lt;&lt; \"Error: Sin Memoria\" &lt;&lt; std::endl;\r\n     exit(1)\r\n }*numero = 10;std::cout &lt;&lt; \"El numero din&aacute;mico es: \" &lt;&lt; *numero &lt;&lt; std::endl;delete numero;<\/code><\/pre>\r\n<p style=\"text-align: justify;\">Al compilar el c&oacute;digo obtendremos el siguiente resultado:<\/p>\r\n<pre class=\"language-cpp\"><code>El numero din&aacute;mico es: 10<\/code><\/pre>\r\n<p style=\"text-align: justify;\">Por lo que, una vez tengamos la lectura correspondiente de la variable din&aacute;mica, podemos pasar a liberar el espacio que ya no es necesario que ocupe.<\/p>\r\n<pre class=\"language-cpp\"><code>delete numero;<\/code><\/pre>\r\n<p style=\"text-align: justify;\">&nbsp;<\/p>\r\n<h1 id=\"f06f\" class=\"yc yd sd be ye yf yg yh lb yi yj yk lf yl ym yn yo yp yq yr ys yt yu yv yw yx bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\"><strong class=\"al\">Memoria Din&aacute;mica en Vectores<\/strong><\/h1>\r\n<p id=\"fa21\" class=\"pw-post-body-paragraph wz xa sd lw b xb yy xd xe xf yz xh xi lg za xk xl ll zb xn xo lq zc xq xr xs fp bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">Imaginemos ahora que nuestro programa busca en un archivo (entre varios registros) que se actualiza constantemente y dependiendo del uso que el usuario le de a nuestro programa una serie de resultados.<\/p>\r\n<p id=\"cf4d\" class=\"pw-post-body-paragraph wz xa sd lw b xb xc xd xe xf xg xh xi lg xj xk xl ll xm xn xo lq xp xq xr xs fp bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">Al estar tratando con registros de los que desconocemos los datos m&aacute;s b&aacute;sicos, como cantidad de registros, no podemos definir un vector de tipo est&aacute;tico, ya que nos pedir&aacute; que le asignemos una cantidad de elementos de manera constante. Por lo que necesitamos hacer uso de la memoria din&aacute;mica:<\/p>\r\n<pre class=\"language-cpp\"><code>int cantidad = cantidadDeRegistros();\r\n int* vNumero = NULL;\r\n vNumero = new int[cantidad];<\/code><\/pre>\r\n<p id=\"1bca\" class=\"pw-post-body-paragraph wz xa sd lw b xb xc xd xe xf xg xh xi lg xj xk xl ll xm xn xo lq xp xq xr xs fp bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">La variable cantidad puede tratarse de una funci&oacute;n que nos retorna el n&uacute;mero de registros que un archivo maneja. No sabemos su cantidad, por lo que lo calculamos con la utilizaci&oacute;n de los m&eacute;todos de Archivos, como fseek y ftell. Una vez nos retorna la cantidad de registros, podemos asign&aacute;rsela al vector de tipo din&aacute;mico.<\/p>\r\n<p id=\"9c11\" class=\"pw-post-body-paragraph wz xa sd lw b xb xc xd xe xf xg xh xi lg xj xk xl ll xm xn xo lq xp xq xr xs fp bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">&iquest;Pero qu&eacute; pasa si el usuario agrega un nuevo registro? Nada especial; la funci&oacute;n que calcula la cantidad de registros nos retornar&aacute; un nuevo n&uacute;mero y se asignar&aacute; sin m&aacute;s al vector din&aacute;mico, el cual acepta cantidades no constantes.<\/p>\r\n<p id=\"4e5c\" class=\"pw-post-body-paragraph wz xa sd lw b xb xc xd xe xf xg xh xi lg xj xk xl ll xm xn xo lq xp xq xr xs fp bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">Al momento de no requerir m&aacute;s la utilizaci&oacute;n del vector, recordemos que seg&uacute;n la complejidad del programa puede ser necesario liberar la memoria. A diferencia de una variable din&aacute;mica que bastaba con colocar el operador delete seguido de la variable, al tratarse de vectores debemos sumarlo un detalle imprescindible:<\/p>\r\n<pre class=\"language-cpp\"><code>delete[] vNumeros;<\/code><\/pre>\r\n<p id=\"6095\" class=\"pw-post-body-paragraph wz xa sd lw b xb xc xd xe xf xg xh xi lg xj xk xl ll xm xn xo lq xp xq xr xs fp bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">Si nos olvidamos de colocar los corchetes, tan solo libera la memoria del primer elemento del vector, lo que puede producir lo que se conoce como Memory Leak.<\/p>\r\n<p class=\"pw-post-body-paragraph wz xa sd lw b xb xc xd xe xf xg xh xi lg xj xk xl ll xm xn xo lq xp xq xr xs fp bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">&nbsp;<\/p>\r\n<h1 id=\"61e9\" class=\"yc yd sd be ye yf yg yh lb yi yj yk lf yl ym yn yo yp yq yr ys yt yu yv yw yx bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\"><strong class=\"al\">Vectores con Cantidades variables<\/strong><\/h1>\r\n<p id=\"eaf1\" class=\"pw-post-body-paragraph wz xa sd lw b xb yy xd xe xf yz xh xi lg za xk xl ll zb xn xo lq zc xq xr xs fp bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">En muchas ocasiones podemos vernos en el inconveniente de no saber la cantidad de elementos con los que debemos inicializar un vector. Para este tipo de casos es necesario encontrar la manera de que podamos reasignar la cantidad de elementos que nuestro vector necesita. Supongamos que queremos acumular en un vector distintos resultados que pueden depender de varios factores, pero que ya no depender de la cantidad de registros. Por ejemplo, queremos tener un vector con todos los a&ntilde;os en el que un tipo de registro cumple una particularidad. Le&iacute;do todo el registro, la condici&oacute;n que necesitamos puede haber sido cumplido por un solo a&ntilde;o o dos, y medida que los usuarios ingresan registros puede que hasta los a&ntilde;os se vayan incrementando.<\/p>\r\n<p id=\"f30f\" class=\"pw-post-body-paragraph wz xa sd lw b xb xc xd xe xf xg xh xi lg xj xk xl ll xm xn xo lq xp xq xr xs fp bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">Para este tipo de caso vamos a necesitar partir del resultado m&iacute;nimo que ser&iacute;a que no haya a&ntilde;os que cumpla con la condici&oacute;n que estamos calculando, por lo que la cantidad de elementos con el que inicia nuestro vector ser&aacute; de cero:<\/p>\r\n<pre class=\"language-cpp\"><code>int cantidad = 0;\r\n int* anios = new int[cantidad];<\/code><\/pre>\r\n<p id=\"fc18\" class=\"pw-post-body-paragraph wz xa sd lw b xb xc xd xe xf xg xh xi lg xj xk xl ll xm xn xo lq xp xq xr xs fp bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">Teniendo nuestro vector iniciado, hacemos uso de la l&oacute;gica que queremos implementar para que analice cada registro o dato que tengamos. &iquest;Pero qu&eacute; pasa si el condicional nos retorna un true, es decir, que se cumple una condici&oacute;n para la que vamos a necesitar guardar el a&ntilde;o del registro en nuestro vector?<\/p>\r\n<p id=\"71ae\" class=\"pw-post-body-paragraph wz xa sd lw b xb xc xd xe xf xg xh xi lg xj xk xl ll xm xn xo lq xp xq xr xs fp bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">No podemos asignarlo sin m&aacute;s, ya que nuestro vector est&aacute; con ceros (0) elementos. En este caso debemos hacer uso de un vector auxiliar que nos permita almacenar el dato y posteriormente pas&aacute;rselo al vector &ldquo;anios&rdquo;.<\/p>\r\n<pre class=\"language-cpp\"><code>int* aux = new int[cantidad + 1];<\/code><\/pre>\r\n<p id=\"ee9d\" class=\"pw-post-body-paragraph wz xa sd lw b xb xc xd xe xf xg xh xi lg xj xk xl ll xm xn xo lq xp xq xr xs fp bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">El vector aux se inicia con un elemento m&aacute;s que el que tenga anio en el momento que sea necesario almacenar un dato. En una primera instancia, anio tiene cero elementos, por lo que aux tendr&aacute; un elemento, suficiente para poder almacenar el dato nuevo.<\/p>\r\n<p id=\"c310\" class=\"pw-post-body-paragraph wz xa sd lw b xb xc xd xe xf xg xh xi lg xj xk xl ll xm xn xo lq xp xq xr xs fp bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">&iquest;Pero qu&eacute; pasa si anio no est&aacute; en cero, es decir que en una segunda instancia tiene almacenado el dato con el primer a&ntilde;o que encontr&oacute;? En este caso debemos asegurarnos de hacer antes que nada una copia de lo que tenga anio al nuevo vector aux:<\/p>\r\n<pre class=\"language-cpp\"><code>for(int i = 0; i &lt; cantidad; i++){      aux[i] = anio[i];}<\/code><\/pre>\r\n<p style=\"text-align: justify;\">Ahora s&iacute;, con la copia realizada podemos almacenar en el vector aux con un elemento de m&aacute;s el nuevo dato:<\/p>\r\n<pre class=\"language-cpp\"><code>aux[cantidad] = nuevoAnio;<\/code><\/pre>\r\n<p id=\"56dc\" class=\"pw-post-body-paragraph wz xa sd lw b xb xc xd xe xf xg xh xi lg xj xk xl ll xm xn xo lq xp xq xr xs fp bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">En la posici&oacute;n cantidad, que ser&aacute; la &uacute;ltima posici&oacute;n (en una primera instancia, al ser cero, ser&aacute; la posici&oacute;n cero) almacenamos el dato que encontramos.<\/p>\r\n<p id=\"371c\" class=\"pw-post-body-paragraph wz xa sd lw b xb xc xd xe xf xg xh xi lg xj xk xl ll xm xn xo lq xp xq xr xs fp bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">&iquest;Y ya est&aacute;? Lamentablemente no, ahora debemos liberar la memoria del vector anio porque se actualiz&oacute; con un nuevo dato. Pero tranquilo, ya est&aacute; copiado todos sus datos anteriores en el vector auxiliar.<\/p>\r\n<pre class=\"language-cpp\"><code>if(cantidadRestaurante &gt; 0){     delete [] vResturante;}<\/code><\/pre>\r\n<p style=\"text-align: justify;\">Ahora s&iacute;, lo m&aacute;s importante, pasamos todo lo que contiene aux a nuestro vector anio, que es la variable que tenemos armada para que vaya acumulando los datos que vamos a ir encontrando:<\/p>\r\n<pre class=\"language-cpp\"><code>vResturante = aux;<\/code><\/pre>\r\n<p style=\"text-align: justify;\">Y por &uacute;ltimo, incrementamos la variable cantidad, para que la siguiente vez que encuentre un nuevo anio pueda continuar ampliando el vector de anio:<\/p>\r\n<pre class=\"language-cpp\"><code>cantidad++;<\/code><\/pre>\r\n<p style=\"text-align: justify;\">&nbsp;<\/p>\r\n<h1 id=\"de60\" class=\"yc yd sd be ye yf yg yh lb yi yj yk lf yl ym yn yo yp yq yr ys yt yu yv yw yx bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\"><strong class=\"al\">Conclusi&oacute;n<\/strong><\/h1>\r\n<p id=\"39b3\" class=\"pw-post-body-paragraph wz xa sd lw b xb yy xd xe xf yz xh xi lg za xk xl ll zb xn xo lq zc xq xr xs fp bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">Usamos Memoria Din&aacute;mica cada vez que no sepamos la cantidad de datos o tama&ntilde;o que vamos a necesitar para poder ejecutar nuestro programa. Solamente tendr&iacute;amos un tama&ntilde;o fijo almacenado en la Memoria Stack que es el puntero en el que guardaremos la direcci&oacute;n de memoria, lo cual ocupa 4 bytes. El resto se almacena en la Memoria Heap.<\/p>",
        "img": "https://miro.medium.com/v2/resize:fit:720/format:webp/1*SnaIgRsnSqr6Wkv9uRbtNA.jpeg",
        "created_at": "2023-07-28 17:50:05",
        "user" : "Alejandro Gomez Nieto",
        "category": "C++"
    },
    {
        "id": 3,
        "title": "Reduce en Javascript",
        "description": "Â¿CÃ³mo se usa y para quÃ© sirve?",
        "field": "<p id=\"5a67\" class=\"pw-post-body-paragraph lb lc ev ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly eo bj lz\" style=\"text-align: justify;\" data-selectable-paragraph=\"\"><span class=\"l ma mb mc bn md me mf mg mh go\">R<\/span>educe es un m&eacute;todo que nos puede servir para simplificar determinadas tareas en donde los m&eacute;todos tradicionales nos pueden complicar. Sin embargo, debemos saber que reduce() es un m&eacute;todo rara vez utilizado. Por lo general, veremos que utilizar el reduce() como un iterador ocasiona otra serie de problemas: el c&oacute;digo pierde legibilidad o implementa una l&oacute;gica exagerada. Y todo esto sin ganar un mejor rendimiento.<\/p>\r\n <p id=\"95eb\" class=\"pw-post-body-paragraph lb lc ev ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly eo bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">Sabiendo esto, comencemos por lo m&aacute;s b&aacute;sico.<\/p>\r\n <p class=\"pw-post-body-paragraph lb lc ev ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly eo bj\" data-selectable-paragraph=\"\">&nbsp;<\/p>\r\n <h1 id=\"43b8\" class=\"mi mj ev be mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bj\" data-selectable-paragraph=\"\"><strong class=\"al\">&iquest;Qu&eacute; es reduce?<\/strong><\/h1>\r\n <p id=\"8694\" class=\"pw-post-body-paragraph lb lc ev ld b le ng lg lh li nh lk ll lm ni lo lp lq nj ls lt lu nk lw lx ly eo bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">reduce es un m&eacute;todo un m&eacute;todo de los arreglos que ejecuta una funci&oacute;n reductora sobre cada uno de los elementos en los que itera. Hasta ac&aacute;, a todos se nos puede ocurrir que un map() tiene un aspecto similar; sin embargo, el verdadero poder que tiene reduce es en el callback que se ejecuta, el cual contiene cuatro argumentos que podemos utilizar:<\/p>\r\n <pre class=\"language-javascript\"><code>arr.reduce(callback(acumulador,   valorActual[, &iacute;ndice[, array]])[, valorInicial])<\/code><\/pre>\r\n <p>&nbsp;<\/p>\r\n <p id=\"43b9\" class=\"pw-post-body-paragraph lb lc ev ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly eo bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\"><strong class=\"ld ew\">1. Acumulador<\/strong><\/p>\r\n <p id=\"fc75\" class=\"pw-post-body-paragraph lb lc ev ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly eo bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">Este argumento guarda todo lo que retorne el <strong class=\"ld ew\">callback <\/strong>(funci&oacute;n reductora), recordando (esto es lo importante) en la siguiente iteraci&oacute;n cu&aacute;l es ese valor, para poder hacer uso de &eacute;l.<\/p>\r\n <p id=\"8f5f\" class=\"pw-post-body-paragraph lb lc ev ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly eo bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\"><strong class=\"ld ew\">2. Valor actual<\/strong><\/p>\r\n <p id=\"a382\" class=\"pw-post-body-paragraph lb lc ev ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly eo bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">Se trata del elemento de nuestro array sobre el que est&aacute; iterando y siendo procesado por el <strong class=\"ld ew\">callback<\/strong>.<\/p>\r\n <p id=\"11a4\" class=\"pw-post-body-paragraph lb lc ev ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly eo bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\"><strong class=\"ld ew\">3. &Iacute;ndice<\/strong><\/p>\r\n <p id=\"93cc\" class=\"pw-post-body-paragraph lb lc ev ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly eo bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">No es m&aacute;s que el &iacute;ndice del <strong class=\"ld ew\">Valor actual<\/strong>. Si le proveemos de un elemento inicial, comenzar&aacute; desde el <strong class=\"ld ew\">&iacute;ndice <\/strong>0; caso contrario, el primer proceso que realic&eacute; ser&aacute; el <strong class=\"ld ew\">&iacute;ndice <\/strong>1. Esto se debe a que el elemento del <strong class=\"ld ew\">&iacute;ndice <\/strong>0 ser&aacute; colocado como <strong class=\"ld ew\">valor inicial<\/strong>.<\/p>\r\n <p id=\"be4a\" class=\"pw-post-body-paragraph lb lc ev ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly eo bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\"><strong class=\"ld ew\">4. Valor inicial<\/strong><\/p>\r\n <p id=\"4601\" class=\"pw-post-body-paragraph lb lc ev ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly eo bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">Este valor ser&aacute; utilizado como acumulador en la primera llamada del <strong class=\"ld ew\">callback<\/strong>. De no contar con un<strong class=\"ld ew\"> valor inicial<\/strong>, el <strong class=\"ld ew\">&iacute;ndice <\/strong>0 ser&aacute; pasado por alto y utilizado como <strong class=\"ld ew\">valor inicial<\/strong>. ejecut&aacute;ndose la funci&oacute;n reductora por primera vez en el <strong class=\"ld ew\">&iacute;ndice <\/strong>1:<\/p>\r\n <pre class=\"language-javascript\"><code>[0,1,2,3,4].reduce(function(valorAnterior, valorActual,   indice, vector){return   valorAnterior + valorActual;});\/\/ Primera llamadavalorAnterior = 0,   valorActual = 1, indice = 1\/\/ Segunda llamadavalorAnterior = 1,   valorActual = 2, indice = 2\/\/ Tercera llamadavalorAnterior = 3,   valorActual = 3, indice = 3\/\/ Cuarta llamadavalorAnterior = 6,   valorActual = 4, indice = 4<\/code><\/pre>\r\n <p style=\"text-align: justify;\">De esta manera, debemos comprender que el <strong class=\"ld ew\">valor inicial <\/strong>es el <strong class=\"ld ew\">&iacute;ndice <\/strong>0. Si le pasamos un <strong class=\"ld ew\">valor inicial<\/strong>, entonces el <strong class=\"ld ew\">&iacute;ndice <\/strong>0 ser&aacute; el <strong class=\"ld ew\">valor inicial<\/strong> que hayamos indicado (Por ejemplo, el n&uacute;mero 10):<\/p>\r\n <pre class=\"language-javascript\"><code>[0,1,2,3,4].reduce(function(valorAnterior, valorActual, indice, vector){return valorAnterior + valorActual;}, 10);\/\/ Primera llamadavalorAnterior = 10, valorActual = 0, indice = 0\/\/ Segunda llamadavalorAnterior = 10, valorActual = 1, indice = 1\/\/ Tercera llamadavalorAnterior = 11, valorActual = 2, indice = 2\/\/ Cuarta llamadavalorAnterior = 13, valorActual = 3, indice = 3\/\/ Quinta llamadavalorAnterior = 16, valorActual = 4, indice = 4<\/code><\/pre>\r\n <p>&nbsp;<\/p>\r\n <h1 id=\"f38f\" class=\"mi mj ev be mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\"><strong class=\"al\">&iquest;Para qu&eacute; sirve reduce?<\/strong><\/h1>\r\n <p id=\"e79b\" class=\"pw-post-body-paragraph lb lc ev ld b le ng lg lh li nh lk ll lm ni lo lp lq nj ls lt lu nk lw lx ly eo bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">Lo primero a tener en cuenta es que <strong class=\"ld ew\">reduce <\/strong>ejecuta un <strong class=\"ld ew\">callback <\/strong>con los elementos de nuestro arreglo, retornando un valor que se <strong class=\"ld ew\">acumula <\/strong>y puede ser utilizado en posteriores iteraciones.<\/p>\r\n <p id=\"56d9\" class=\"pw-post-body-paragraph lb lc ev ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly eo bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">&iquest;Por qu&eacute; empiezo por ac&aacute;? Porque es importante entender que el <strong class=\"ld ew\">callback <\/strong>que ejecuta reduce siempre debe retornar algo. caso contrario, el acumulador queda indefinido. Olvidarnos de retornar un valor es igual a cortar el flujo que el reduce necesita para funcionar.<\/p>\r\n <p id=\"aa23\" class=\"pw-post-body-paragraph lb lc ev ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly eo bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">De esta manera, podemos entender el uso m&aacute;s simple y primario que podemos encontrar en cada ejemplo que nos crucemos:<\/p>\r\n <pre class=\"language-javascript\"><code>[0, 1, 2, 3, 4].reduce((valorAnterior, valorActual) =&gt; {return valorAnterior + valorActual})<\/code><\/pre>\r\n <p style=\"text-align: justify;\">Lo que nos retorna en este caso reduce es la suma total de los elementos del arreglo. Lo que sucede, aplicando lo visto hasta ac&aacute;, es una suma entre lo que se acumula y el elemento sobre el que se itera. El retorno es la suma, por lo que en el primer llamado retorna el valor de 1 (0 + 1). Para el segundo llamado, el <strong class=\"ld ew\">valor acumulado <\/strong>pasa de ser 0 a ser 1, por lo que la suma que realiza ahora es 1 + 2, retornando 3:<\/p>\r\n <pre class=\"language-javascript\"><code>\/\/ Primera llamadavalorAnterior = 0,   valorActual = 1, indice = 1\/\/ Segunda llamadavalorAnterior = 1,   valorActual = 2, indice = 2\/\/ Tercera llamadavalorAnterior = 3,   valorActual = 3, indice = 3\/\/ Cuarta llamadavalorAnterior = 6,   valorActual = 4, indice = 4<\/code><\/pre>\r\n <p style=\"text-align: justify;\"><em>Al no haberle colocado un valor inicial, se ejecuta directamente sobre el elemento de &iacute;ndice 1. utilizando al elemento de &iacute;ndice 0 como su valor anterior o acumulado.<\/em><\/p>\r\n <p id=\"57ea\" class=\"pw-post-body-paragraph lb lc ev ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly eo bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">El valor primario de un reduce, entonces, radica en su valor acumulado y en que el callback que ejecuta es el mismo en cada iteraci&oacute;n. Pens&aacute;ndolo de esta manera, entonces, es f&aacute;cil caer en querer utilizar un reduce para todo tipo de ejemplos.<\/p>\r\n <p class=\"pw-post-body-paragraph lb lc ev ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly eo bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">&nbsp;<\/p>\r\n <p id=\"515a\" class=\"pw-post-body-paragraph lb lc ev ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly eo bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\"><strong class=\"ld ew\">Ejemplo<\/strong><\/p>\r\n <p id=\"f031\" class=\"pw-post-body-paragraph lb lc ev ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly eo bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">imaginemos que se nos asigna un arreglo con elementos num&eacute;ricos que se repiten. Se nos indica que debemos producir un programa capaz de retornar un arreglo con elementos &uacute;nicos.<\/p>\r\n <pre class=\"language-javascript\"><code>const arreglo = [0, 1, 2, 3, 4, 0, 1, 1, 2, 5, 6, 7, 4, 8, 7, 5]<\/code><\/pre>\r\n <p style=\"text-align: justify;\">Lo primero que debemos hacer es colocar la estructura b&aacute;sica del arreglo:<\/p>\r\n <pre class=\"language-javascript\"><code>arreglo.reduce((valorAnterior, valorActual) =&gt; {}, [])<\/code><\/pre>\r\n <p id=\"502e\" class=\"pw-post-body-paragraph lb lc ev ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly eo bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">El <strong class=\"ld ew\">valor inicial <\/strong>que colocaremos ser&aacute; un arreglo, ya que es donde iremos guardando los valores que necesitamos y porque as&iacute; lo indica el ejercicio. De no poner un arreglo como valor inicial, los resultados no se podr&aacute;n guardar, retornando el &uacute;ltimo valor num&eacute;rico.<\/p>\r\n <p id=\"6230\" class=\"pw-post-body-paragraph lb lc ev ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly eo bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">Sabiendo que en el primer llamado el <strong class=\"ld ew\">callback <\/strong>iterar&aacute; sobre el elemento con &iacute;ndice 0 de nuestro arreglo, y que el valor inicial es un arreglo, podemos ir haciendo consultas que nos permita saber si el elemento que se ejecuta se encuentra en el arreglo; caso contrario lo colocamos:<\/p>\r\n <pre class=\"language-javascript\"><code>arreglo.reduce((valorAnterior, valorActual) =&gt; {if(!valorAnterior.includes(valorActual)){return [...valorAnterior, valorActual]}return   valorAnterior}, [])<\/code><\/pre>\r\n <p style=\"text-align: justify;\"><em>Recordar siempre colocar un valor de retorno si utilizamos condicionales, caso contrario el valor acumulado pasa a ser indefinido.<\/em><\/p>\r\n <p style=\"text-align: justify;\">&nbsp;<\/p>\r\n <p id=\"b58e\" class=\"pw-post-body-paragraph lb lc ev ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly eo bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\"><strong class=\"ld ew\">Ejemplo 2<\/strong><\/p>\r\n <p id=\"659a\" class=\"pw-post-body-paragraph lb lc ev ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly eo bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">Pensemos ahora que tenemos el mismo arreglo repetido, pero que a la vez est&aacute; dividido por sub-arreglos. Lo que se nos pide es el mimos resultado: un arreglo con elementos &uacute;nicos y sin sub arreglos.<\/p>\r\n <p id=\"b6f8\" class=\"pw-post-body-paragraph lb lc ev ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly eo bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">Lo que podemos hacer primero es determinar si dentro del arreglo hay otros arreglos:<\/p>\r\n <pre class=\"language-javascript\"><code>const vec = [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [1, 2, 3], 4, [5, 6, 7, 8], 9, 10]const venReduce = vec.reduce((valorAnterior, valorActual) =&gt; {\r\n  if(Array.isArray(valorActual)){  \/\/ si es sub-arreglo, ingresa }\r\n   return valorAnterior\r\n },[])<\/code><\/pre>\r\n <p id=\"5e9e\" class=\"pw-post-body-paragraph lb lc ev ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly eo bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">De tratarse de un sub-arreglo, ingresamos al condicional. Caso contrario, nos retorna lo que el acumulador tenga de iteraciones anteriores.<\/p>\r\n <p id=\"9d1a\" class=\"pw-post-body-paragraph lb lc ev ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly eo bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">Una vez dentro del condicional podemos aplicar la misma l&oacute;gica anterior.<\/p>\r\n <pre class=\"language-javascript\"><code>const venReduce = vec.reduce((valorAnterior, valorActual) =&gt; {\r\n  if(Array.isArray(valorActual)){   value.forEach( value =&gt; {\r\n      if(!valorAnterior.includes(value)){\r\n         valorAnterior.push(value)\r\n      }\r\n    })}\r\n   return valorAnterior\r\n },[])<\/code><\/pre>\r\n <p id=\"bfda\" class=\"pw-post-body-paragraph lb lc ev ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly eo bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">Dentro del condicional consultamos cada elemento del sub-arreglo con un <strong class=\"ld ew\">forEach<\/strong> para poder determinar, con un segundo condicional, si esos elementos ya se encuentran en el <strong class=\"ld ew\">valor anterior<\/strong>. De ser falso (Es decir, que se encuentran ya registrados) , pasa a iterar el siguiente elemento del sub-arreglo. Pero si no est&aacute;n incluidos, deberemos incluirlos utilizando el m&eacute;todo <strong class=\"ld ew\">push<\/strong>.<\/p>\r\n <p class=\"pw-post-body-paragraph lb lc ev ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly eo bj\" data-selectable-paragraph=\"\">&nbsp;<\/p>\r\n <h1 id=\"6dbd\" class=\"mi mj ev be mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\"><strong>Problemas con reduce<\/strong><\/h1>\r\n <p id=\"e0ec\" class=\"pw-post-body-paragraph lb lc ev ld b le ng lg lh li nh lk ll lm ni lo lp lq nj ls lt lu nk lw lx ly eo bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">Si tienen la oportunidad de ver el video que sac&oacute; <a class=\"af oi\" href=\"https:\/\/www.youtube.com\/watch?v=qaGjS7-qWzg\" target=\"_blank\" rel=\"noopener ugc nofollow\">HTTP 203<\/a> podr&aacute;n entender los aspectos que m&aacute;s desagradan a todo programador.<\/p>\r\n <p id=\"cb30\" class=\"pw-post-body-paragraph lb lc ev ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly eo bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">La utilidad real que podemos hacer de <strong class=\"ld ew\">reduce <\/strong>es escasa, y rara vez tendremos la posibilidad de hacer uso de este m&eacute;todo. Por el contrario, reduce puede ser mal interpretado por aquellos que no tengan pr&aacute;ctica, como tambi&eacute;n convertirse en un dolor de cabeza para quienes deben revisar tu c&oacute;digo.<\/p>\r\n <p id=\"e272\" class=\"pw-post-body-paragraph lb lc ev ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly eo bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">No debemos caer en querer utilizar <strong class=\"ld ew\">reduce <\/strong>tan solo por ser ingeniosos. Es cierto que <strong class=\"ld ew\">reduce <\/strong>puede convertirse en una gran compa&ntilde;ero de pr&aacute;ctica en los primeros meses que abordamos <strong class=\"ld ew\">Javascript<\/strong>: se hacen divertidas las ocurrencias que podemos producir, los algoritmos complejos que solamente realizan una tarea tan simple como la que podemos conseguir con el m&eacute;todo <strong class=\"ld ew\">flat<\/strong> (como en el ejemplo 2), o utilizarlo como un simple iterador. Y est&aacute; bien hacer pr&aacute;cticas y tontear un buen rato en <strong class=\"ld ew\">RunJS<\/strong>. Sin embargo, hay que evitarlo a la hora de producir c&oacute;digo que otros van a leer.<\/p>\r\n <p id=\"ee67\" class=\"pw-post-body-paragraph lb lc ev ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly eo bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">La manera en la que se escribe el c&oacute;digo <strong class=\"ld ew\">reduce <\/strong>no es de lectura secuencial. Siempre que nos topemos con un <strong class=\"ld ew\">reduce <\/strong>deberemos primero ir al final del c&oacute;digo para conocer su valor inicial; para luego retornar al inicio e intentar incrustarlo en aquellas porciones de c&oacute;digo que nos puedan arrojar un poco de claridad. Esto hace que una tarea que puede llevarnos unos escasos segundos, se torne un trabajo que demande una cantidad de atenci&oacute;n innecesaria.<\/p>\r\n <p class=\"pw-post-body-paragraph lb lc ev ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly eo bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">&nbsp;<\/p>\r\n <p id=\"7dde\" class=\"pw-post-body-paragraph lb lc ev ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly eo bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\"><strong class=\"ld ew\">Mayor valor<\/strong><\/p>\r\n <p id=\"4808\" class=\"pw-post-body-paragraph lb lc ev ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly eo bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">Imaginemos que tenemos un arreglo y se nos pide que retornemos el el mayor elemento:<\/p>\r\n <pre class=\"language-javascript\"><code>const vec = [55, 4, 25, 36, 95, 1, 2, 78, 6]const venReduce = vec.reduce((valorAnterior, valorActual) =&gt; {\r\n   if(valorAnterior&lt; valorActual){\r\n     return valorActual\r\n   }\r\n   return valorAnterior\r\n })<\/code><\/pre>\r\n <p id=\"ee2e\" class=\"pw-post-body-paragraph lb lc ev ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly eo bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">Iteramos en cada elemento y vamos consultando si el <strong class=\"ld ew\">valor actual<\/strong> es mayor al <strong class=\"ld ew\">valor inicial <\/strong>o que estamos <strong class=\"ld ew\">acumulando<\/strong>. Si la respuesta es afirmativa, retornamos el <strong class=\"ld ew\">valor actual <\/strong>(el cual se transforma en el <strong class=\"ld ew\">valor anterior<\/strong>), caso contrario, continuamos con el <strong class=\"ld ew\">valor anterior<\/strong>.<\/p>\r\n <p id=\"cdf2\" class=\"pw-post-body-paragraph lb lc ev ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly eo bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">Sin embargo, este algoritmo se podr&iacute;a reducir al siguiente m&eacute;todo <strong class=\"ld ew\">Math<\/strong>:<\/p>\r\n <pre class=\"language-javascript\"><code>const maxValue = Math.max(...vec)<\/code><\/pre>\r\n <p id=\"8b9f\" class=\"pw-post-body-paragraph lb lc ev ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly eo bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">A los ojos de cualquiera, en el primer caso tenemos que frenarnos a pensar qu&eacute; est&aacute; sucediendo; mientras que en el segundo caso no hay mucho que pensar.<\/p>\r\n <p class=\"pw-post-body-paragraph lb lc ev ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly eo bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">&nbsp;<\/p>\r\n <h1 id=\"a10b\" class=\"mi mj ev be mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\"><strong class=\"al\">Conclusiones<\/strong><\/h1>\r\n <p id=\"d20a\" class=\"pw-post-body-paragraph lb lc ev ld b le ng lg lh li nh lk ll lm ni lo lp lq nj ls lt lu nk lw lx ly eo bj\" style=\"text-align: justify;\" data-selectable-paragraph=\"\">Muchas de los problemas que intentemos resolver con <strong class=\"ld ew\">Reduce<\/strong>, es muy probable que exista un m&eacute;todo o una manera m&aacute;s simple de hacerlo (<strong class=\"ld ew\">forEach, map, filter&hellip;<\/strong>) Por lo que, antes de sacrificar legibilidad en nuestro c&oacute;digo, debemos cuestionarnos si no existe algo m&aacute;s f&aacute;cil.<\/p>",
        "img": "https://miro.medium.com/v2/resize:fit:720/format:webp/1*dVBwBb5xZXof_DEPTfvbHw.png",
        "created_at": "2023-07-22 20:33:56",
        "user" : "Alejandro Gomez Nieto",
        "category": "JavaScript"
    },
    {
        "id": 4,
        "title": "Static cast",
        "description": "Ejemplos de uso de static_cast",
        "field": "<p><strong>static_cast<\/strong> realiza conversiones impl&iacute;citas entre tipos. Las conversiones impl&iacute;citas son aquellas que el programa realiza autom&aacute;ticamente sin necesidad de que le indiquemos expl&iacute;citamente que realice una conversi&oacute;n.<\/p>\r\n<p>Por ejemplo:<\/p>\r\n<pre class=\"language-cpp\"><code>float a = 4.5;\r\nint b;\r\nb = a;<\/code><\/pre>\r\n<p>Tanto <strong>static_cast<\/strong> como la conversi&oacute;n impl&iacute;cita realizan el mismo trabajo. Sin embargo, optamos por usar <strong>static_cast<\/strong> para que nuestro c&oacute;digo sea m&aacute;s legible. No es lo mismo realizar una conversi&oacute;n impl&iacute;cita entre dos variables declaradas unas l&iacute;neas arriba que utilizar <strong>static_cast<\/strong>. Con la segunda opci&oacute;n, dejamos en claro que estamos realizando una conversi&oacute;n:<\/p>\r\n<pre class=\"language-cpp\"><code>b = static_cast&lt;int&gt;(a);<\/code><\/pre>\r\n<p>Otro uso se da en el caso de la conversi&oacute;n por construcci&oacute;n u operadores.<\/p>\r\n<p>Supongamos que tenemos una clase que recibe un entero:<\/p>\r\n<pre class=\"language-cpp\"><code>class Int {\r\n    int x;\r\npublic:\r\n    Int(int x = 0) : x(x) {}\r\n};<\/code><\/pre>\r\n<p>Por conversi&oacute;n impl&iacute;cita podr&iacute;amos hacer lo siguiente:<\/p>\r\n<pre class=\"language-cpp\"><code>Int obj(10);\r\nobj = 20;<\/code><\/pre>\r\n<p>Siempre que la clase tenga un solo par&aacute;metro, podemos inicializarla por constructor como si se tratara de una asignaci&oacute;n. Pero tambi&eacute;n podemos utilizar <strong>static_cast<\/strong> para que el entero que queremos asignar por constructor primero pase al tipo de clase que corresponde:<\/p>\r\n<pre class=\"language-cpp\"><code>obj = static_cast&lt;Int&gt;(30);<\/code><\/pre>\r\n<p>Si a la misma clase le agregamos un operador que nos permita pasar la propiedad entera a string:<\/p>\r\n<pre class=\"language-cpp\"><code>class Int {\r\n    int x;\r\npublic:\r\n    Int(int x = 0) : x(x) {}\r\n\r\n    operator string() {\r\n        cout &lt;&lt; \"Operador string\" &lt;&lt; endl;\r\n        return to_string(x);\r\n    }\r\n};\r\n<\/code><\/pre>\r\n<p>De manera impl&iacute;cita podr&iacute;amos hacer:<\/p>\r\n<pre class=\"language-cpp\"><code>string str1 = obj;<\/code><\/pre>\r\n<p>Sin embargo, quien lea nuestro c&oacute;digo no sabr&iacute;a de entrada por qu&eacute; esto es posible. Tendr&iacute;a que ver la clase y entender que estamos utilizando un operador para convertir el objeto a string. Por eso, el uso de <strong>static_cast<\/strong> facilita su lectura:<\/p>\r\n<pre class=\"language-cpp\"><code>string str2 = static_cast&lt;string&gt;(obj);<\/code><\/pre>\r\n<p>Otro aspecto a tener en cuenta es que <strong>static_cast<\/strong> es m&aacute;s restrictivo que la conversi&oacute;n impl&iacute;cita. Por ejemplo, en un caso en que queramos pasar un puntero de char (<code>char*<\/code>) a un puntero de int (<code>int*<\/code>), no tendremos inconvenientes en la conversi&oacute;n impl&iacute;cita al momento en que lo hacemos. Sin embargo, nos arrojar&aacute; un error al compilar por intentar interpretar un dato de 4 bytes cuando solo puede acceder a un dato de 1 byte:<\/p>\r\n<pre class=\"language-cpp\"><code>char c;\r\nint* ptr = (int*)&amp;c;\r\n*ptr = 2;<\/code><\/pre>\r\n<p>Cuando utilizamos <strong>static_cast<\/strong>, no seremos capaces de realizar esta conversi&oacute;n, puesto que no son tipos de punteros compatibles:<\/p>\r\n<pre class=\"language-cpp\"><code>int* ptr2 = static_cast&lt;int*&gt;(&amp;c);<\/code><\/pre>\r\n<p>Un <code>char*<\/code> se espera que apunte a un byte de datos, mientras que un <code>int*<\/code> se espera que apunte a una secuencia de 4 bytes (en un sistema de 32 bits) que representan un entero.<\/p>\r\n<p>Algo similar ocurre cuando trabajamos con clases, donde heredamos una clase como privada:<\/p>\r\n<pre class=\"language-cpp\"><code>class Base{};\r\nclass Derivada: private Base{};<\/code><\/pre>\r\n<p>Lo que significa que sea privada es que, por fuera de <code>Derivada<\/code>, no podremos acceder a los atributos que sean p&uacute;blicos o protegidos de <code>Base<\/code>. Todos estos atributos p&uacute;blicos o protegidos se convierten en privados para <code>Derivada<\/code>. Es por esto que no somos capaces de realizar cast, ya que por fuera de <code>Derivada<\/code> la clase <code>Base<\/code> es inaccesible.<\/p>\r\n<p>Sin embargo, esto es algo que vemos en tiempo de compilaci&oacute;n cuando utilizamos la conversi&oacute;n impl&iacute;cita:<\/p>\r\n<pre class=\"language-cpp\"><code>Derivada d1;\r\nBase* bptr = (Base*)&amp;d1;<\/code><\/pre>\r\n<p>Pero con <code>static_cast<\/code>, podremos verlo en el momento de estar intentando realizar la conversi&oacute;n.<\/p>\r\n<p>En otro ejemplo, nunca debemos utilizar <strong>static_cast <\/strong>cuando hacemos downcasting. Es decir, cuando pasamos una clase a su clase base y luego queremos volver a pasarla a su clase anterior. Esto se debe a que podemos cometer errores que no son notificados en ning&uacute;n momento, ni siquiera en tiempo de compilaci&oacute;n:<\/p>\r\n<pre class=\"language-cpp\"><code>Derivada1 d1;\r\nDerivada2 d2;\r\n\r\n\/\/ Upcast\r\nBase* bptr1 = static_cast&lt;Base*&gt;(&amp;d1);\r\nBase* bptr2 = static_cast&lt;Base*&gt;(&amp;d2);\r\n\r\n\/\/ Downcast\r\nDerivada1* dptr1 = static_cast&lt;Derivada1*&gt;(bptr2); \/\/ Intercambiamos los objetos\r\nDerivada2* dptr2 = static_cast&lt;Derivada2*&gt;(bptr1);\r\n<\/code><\/pre>\r\n<p>Finalmente, siempre debemos utilizar <code>static_cast<\/code> cuando estamos trabajando con punteros <code>void<\/code>:<\/p>\r\n<pre class=\"language-cpp\"><code>int i = 10;\r\nvoid* v = static_cast&lt;void*&gt;(&amp;i);\r\nint* p = static_cast&lt;int*&gt;(v);<\/code><\/pre>\r\n<p>Esto se debe a reglas predefinidas para convertir cualquier cosa a un puntero vac&iacute;o. <strong>static_cast<\/strong> sabe c&oacute;mo hacerlo.<\/p>",
        "img": "https://i.imgur.com/HYdJkza.png",
        "created_at": "2024-02-11 15:33:56",
        "user" : "Alejandro Gomez Nieto",
        "category": "C++"
    }
]